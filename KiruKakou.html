<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>自己交差テスト</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
        #debug {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255,255,255,0.8);
            padding: 5px;
            font-family: monospace;
        }
    </style>
</head>
<body>
<div id="debug">交差数: 0<br>面積: 0</div>
<script type="module">
    import Phaser from 'https://cdn.jsdelivr.net/npm/phaser@3.55.2/+esm';

    class MyGame extends Phaser.Scene {
        constructor() {
            super();
            this.graphics = null;
            this.points = [];
            this.square = null;
        }

        preload() {}

        create() {
            this.graphics = this.add.graphics({ lineStyle: { width: 2, color: 0x00ff00 } });

            // 正方形（ターゲット）の描画
            this.square = new Phaser.Geom.Rectangle(
                this.cameras.main.centerX - 10,
                this.cameras.main.centerY - 10,
                20,
                20
            );
            this.add.graphics({ fillStyle: { color: 0xff0000 } }).fillRectShape(this.square);

            this.input.on('pointerdown', pointer => {
                this.points = [pointer.position.clone()];
                this.graphics.clear();
            });

            this.input.on('pointermove', pointer => {
                if (pointer.isDown) {
                    this.points.push(pointer.position.clone());
                    this.redraw();
                }
            });

            this.input.on('pointerup', () => {
                const intersections = findSelfIntersections(this.points);
                const debugEl = document.getElementById('debug');
                debugEl.innerHTML = `交差数: ${intersections.length}`;

                if (intersections.length === 1) {
                    const loop = extractLoop(this.points, intersections[0].i1, intersections[0].i2);
                    const area = polygonArea(loop);
                    debugEl.innerHTML += `<br>面積: ${Math.abs(area).toFixed(2)}`;

                    if (polygonIntersectsRect(loop, this.square)) {
                        debugEl.innerHTML += `<br><strong>ENCIRCLED!</strong>`;
                    }

                } else if (intersections.length === 0) {
                    const length = polylineLength(this.points);
                    debugEl.innerHTML += `<br>長さ: ${length.toFixed(2)}`;

                    if (length > 5 && pathIntersectsRect(this.points, this.square)) {
                        debugEl.innerHTML += `<br><strong>HIT!</strong>`;
                    }
                }
            });
        }

        redraw() {
            this.graphics.clear();
            this.graphics.strokePoints(this.points, false);
        }
    }

    function findSelfIntersections(points) {
        const intersections = [];
        for (let i = 0; i < points.length - 2; i++) {
            for (let j = i + 2; j < points.length - 1; j++) {
                if (i === 0 && j === points.length - 2) continue;
                if (segmentsIntersect(points[i], points[i + 1], points[j], points[j + 1])) {
                    intersections.push({ i1: i, i2: j });
                }
            }
        }
        return intersections;
    }

    function segmentsIntersect(p1, p2, q1, q2) {
        const d = (p2.x - p1.x) * (q2.y - q1.y) - (p2.y - p1.y) * (q2.x - q1.x);
        if (d === 0) return false;
        const t = ((q1.x - p1.x) * (q2.y - q1.y) - (q1.y - p1.y) * (q2.x - q1.x)) / d;
        const u = ((q1.x - p1.x) * (p2.y - p1.y) - (q1.y - p1.y) * (p2.x - p1.x)) / d;
        return t >= 0 && t <= 1 && u >= 0 && u <= 1;
    }

    function extractLoop(points, i1, i2) {
        const loop = [points[i1]];
        for (let i = i1 + 1; i <= i2; i++) {
            loop.push(points[i]);
        }
        loop.push(points[i1]);
        return loop;
    }

    function polygonArea(points) {
        let area = 0;
        for (let i = 0; i < points.length - 1; i++) {
            area += (points[i].x * points[i + 1].y - points[i + 1].x * points[i].y);
        }
        return area / 2;
    }

    function polylineLength(points) {
        let length = 0;
        for (let i = 0; i < points.length - 1; i++) {
            const dx = points[i + 1].x - points[i].x;
            const dy = points[i + 1].y - points[i].y;
            length += Math.sqrt(dx * dx + dy * dy);
        }
        return length;
    }

    function pathIntersectsRect(pathPoints, rect) {
        for (let i = 0; i < pathPoints.length - 1; i++) {
            const p1 = pathPoints[i];
            const p2 = pathPoints[i + 1];
            if (Phaser.Geom.Intersects.LineToRectangle(
                new Phaser.Geom.Line(p1.x, p1.y, p2.x, p2.y), rect)) {
                return true;
            }
        }
        return false;
    }

    function polygonIntersectsRect(polygonPoints, rect) {
        const polygon = new Phaser.Geom.Polygon(polygonPoints);
        // 1. 矩形の4隅のうちどれかがポリゴン内部にあるか
        const corners = [
            new Phaser.Geom.Point(rect.x, rect.y),
            new Phaser.Geom.Point(rect.x + rect.width, rect.y),
            new Phaser.Geom.Point(rect.x + rect.width, rect.y + rect.height),
            new Phaser.Geom.Point(rect.x, rect.y + rect.height)
        ];
        for (const corner of corners) {
            if (Phaser.Geom.Polygon.Contains(polygon, corner.x, corner.y)) {
                return true;
            }
        }
        // 2. ポリゴンの頂点のうちどれかが矩形内部にあるか
        for (const p of polygonPoints) {
            if (Phaser.Geom.Rectangle.ContainsPoint(rect, p)) {
                return true;
           }
        }
        // 3. ポリゴンの辺と矩形の辺が交差しているか
        for (let i = 0; i < polygonPoints.length - 1; i++) {
            const line = new Phaser.Geom.Line(polygonPoints[i].x, polygonPoints[i].y, polygonPoints[i + 1].x, polygonPoints[i + 1].y);
            if (Phaser.Geom.Intersects.LineToRectangle(line, rect)) {
                return true;
            }
        }
        return false;
    }

    new Phaser.Game({
        type: Phaser.AUTO,
        width: window.innerWidth,
        height: window.innerHeight,
        backgroundColor: '#000000',
        scene: MyGame
    });
</script>
</body>
</html>